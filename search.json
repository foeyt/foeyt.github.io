[{"title":"C 语言实现 sin(x) 的 Taylor 展开，同时贯彻递归思想","url":"/2025/10/05/C-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-sin-x-%E7%9A%84%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B4%AF%E5%BD%BB%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/","content":"C 语言实现\r\nsin(x) 的 Taylor 展开，同时贯彻递归思想\r\n过去布置的一道算法作业，网上许多用到的是循环思路，这里给出用递归解决的方案。\r\n接触 C\r\n语言不多，所以写的感觉有些冗长，用到了许多三元运算符来保证代码行数不要太多，能精简多少是多少。\r\n首先先说明一下 sin(x) 的 Taylor 展开（这里其实是 Maclaurin 公式）。\r\n$$\r\n\\begin{flalign}\r\n\\sin x = x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\cdots=\\sum_{i=0,i\\in\r\n\\mathbb{N}}^{+\\infty}(-1)^n\\frac{x^{2n+1}}{(2n+1)!}\r\n\\end{flalign}\r\n$$\r\n\r\n二话不说先上全部代码！\r\n#include &lt;stdio.h&gt;#define calculate(x) taylor(x, 1)unsigned long long int gammaFunction(unsigned int x)&#123;      return (x == 0) ? 1 : ((unsigned long long int) x * gammaFunction(x - 1));&#125;double power(double x, unsigned int y)&#123;    double r = x;    if (y != 0)    &#123;        for(unsigned int i = 0; i &lt; y - 1; i++)            r *= x;    &#125;    else r = 1;    return r;&#125;double absoluteValue(double x)&#123;    return (x &gt;= 0) ? x : (-x);&#125;double taylor(double x, unsigned int n)&#123;    double formla = (power(x, n)) / (gammaFunction(n));    if (absoluteValue(formla &lt; 1e-7)) return formla;    (n % 2 == 0) ? (formla = formla + taylor(x, n + 2)) : (formla = formla - taylor(x, n + 2));    n++;    return formla;&#125;int main()&#123;    double x;    scanf(&quot;%lf&quot;, &amp;x);    printf(&quot;Result: %lf&quot;, calculate(x));    return 0;&#125;\r\n下面开始逐步解释\r\n\r\n阶乘的计算\r\nunsigned long long int gammaFunction(unsigned int x)&#123;      return (x == 0) ? 1 : ((unsigned long long int) x * gammaFunction(x - 1));&#125;\r\n阶乘计算这里用到了 Euler 发现的 Gamma\r\n函数，该函数自带递归性质，于是这里用同样的递归思路解决问题。\r\n用到了三元操作符来排除输入为 0 的特殊情况。\r\nGamma 函数的递归性质如下 $$\r\n\\begin{flalign}\r\n\\Gamma(x)=x\\cdot\\Gamma(x-1)=x(x-1)\\cdot\\Gamma(x-2)=\\cdots=x!\r\n\\end{flalign}\r\n$$\r\n\r\n幂的计算\r\ndouble power(double x, unsigned int y)&#123;    double r = x;    if (y != 0)    &#123;        for(unsigned int i = 0; i &lt; y - 1; i++)            r *= x;    &#125;    else r = 1;    return r;&#125;\r\n这里还是用了 for\r\n循环，我后来想了下可以用递归实现，但是懒得改代码了，读者可以自行尝试下。\r\n同样用 if-else 语句排除输入 x 为 0 的特殊情况。\r\n这里 i &lt; y - 1 的原因是这样的，假设我要算 4\r\n次方幂，输入 y = 4，下面的 for 循环会执行 5\r\n次（0、1、2、3、4），实际上是 5 次方幂，另一个解决方案是\r\nint i = 1。一开始写的时候没想到这个 bug，后来 debug\r\n的时候才发现（😓）。\r\n\r\n单项 Taylor 展开的计算\r\ndouble taylor(double x, unsigned int n)&#123;    double formla = (power(x, n)) / (gammaFunction(n));    if (absoluteValue(formla &lt; 1e-7)) return formla;    (n % 2 == 0) ? (formla = formla + taylor(x, n + 2)) : (formla = formla - taylor(x, n + 2));    n++;    return formla;&#125;\r\n这里定义了\r\ndouble formla，是单项的一个展开，因此下面用三元操作符判断项数奇偶性，参数\r\nn 就是当前的项数。\r\n由于题目要求，我限制了精度在 1e-7\r\n即可，因此这里写了一个获取绝对值的函数，非常好写，一个三元操作符搞定，就不用说明了。\r\n这部分代码重头戏在这个三元操作符上：\r\n(n % 2 == 0) ? (formla = formla + taylor(x, n + 2)) : (formla = formla - taylor(x, n + 2));\r\nn % 2 == 0\r\n用于判断项数奇偶性，决定有没有负号，同时运用递归，即再次调用该函数来实现向后的计算，x\r\n的值不变，项数向后 n + 2 来确保一直取的是奇数。\r\n另外在预处理部分我定义了这样的记号：\r\n#define calculate(x) taylor(x, 1)\r\n因为计算是从\r\nn = 1开始进行的，后来我一想，我定义一个全局变量不就行了吗，何必如此大费周章（😓）（其实还是最近\r\nPython 用多了，习惯了里边函数可以设置默认值了）。\r\n","categories":["计算机程序设计(C)"],"tags":["编程","算法","C"]},{"title":"利用 C 语言实现任意长度字符串字母小写转大写","url":"/2025/10/05/%E5%88%A9%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E9%95%BF%E5%BA%A6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AF%8D%E5%B0%8F%E5%86%99%E8%BD%AC%E5%A4%A7%E5%86%99/","content":"利用 C\r\n语言实现任意长度字符串字母小写转大写\r\n如题，这本来是布置的一道手写代码算法作业，我自己稍微加大了点难度，将这个换成了任意长度字符串并且可能有空格的输入。\r\n另外我与手写代码不共戴天之仇！本来挺快敲完跑路的结果手写代码硬控我一天！\r\n具体涉及了字符型指针与字符型的计算问题，我自我认为我目前对指针了解与运用还是可以的，但是还没搞过内存管理，以后抽时间学习一下。\r\n\r\n二话不说先上代码。\r\n#include &lt;stdio.h&gt;void printString(const char *str)&#123;    for (int i = 0; *(str + i) != 0; i++)        printf(&quot;%c&quot;, *(str + i));&#125;void getUpperCase(char *str)&#123;    for (int i = 0; *(str + i) != 0; i++)    &#123;        if (*(str + i) &gt;= &#x27;a&#x27; &amp;&amp; *(str + i) &lt;= &#x27;z&#x27;)            *(str + i) = (char) (*(str + i) - (&#x27;a&#x27;- &#x27;A&#x27;));    &#125;&#125;int main()&#123;    char *str;    scanf(&quot;%[^\\n]&quot;, str);    getUpperCase(str);    printString(str);    return 0;&#125;\r\n整体没啥好说的，挑几个重点说明下。\r\n首先我用字符型指针来存字符串，保证了任意长度的可能。其次对\r\nscanf() 函数，这里用到了 \"%[^\\n]\"\r\n来获取所有输入直到按下回车键。scanf()\r\n函数并不会获取空格，在检测空格时就停止了输入，在空格后面的一切都不会存入变量。这里我到网上查询了许多，发现这样的方式是我个人感觉最贴合的输入方式。\r\n下面就是 printString() 函数，其实没啥好说的，一个 for\r\n循环遍历输出所有字符，但是注意 *str 指针指向的是\r\nstr[0] 通过给指针进行运算来遍历，我附一张图片（比较粗糙，Ps\r\n上随便搞了一张）\r\n\r\n只要 str + i 指向了末尾的 0 （C 语言会默认在最后加一个\r\n0），就结束输出。\r\n重点就在于让小写变成大写，只需要进行简单的计算即可。\r\nfor (int i = 0; *(str + i) != 0; i++)&#123;    if (*(str + i) &gt;= &#x27;a&#x27; &amp;&amp; *(str + i) &lt;= &#x27;z&#x27;)        *(str + i) = (char) (*(str + i) - (&#x27;a&#x27;- &#x27;A&#x27;));&#125;\r\n首先同样进行遍历，选择出 ASCII 码比 a 大或等于 a，同时比 z 小或等于 z\r\n的字符就是小写字符。\r\n将字符 ASCII 码减去小写字母与大写字母中间差的那些数即得到大写字母的\r\nASCII 码，另外在 ASCII 中，小写是在大写后面的。\r\n最后附一张 ASCII 表供查阅。\r\n\r\n\r\nASCII-1\r\n\r\n\r\n\r\nASCII-2\r\n\r\n","categories":["计算机程序设计(C)"],"tags":["编程","算法","C"]},{"title":"利用 C 语言实现已知三条边判断三角形形状并计算其面积","url":"/2025/10/05/%E5%88%A9%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%B7%B2%E7%9F%A5%E4%B8%89%E6%9D%A1%E8%BE%B9%E5%88%A4%E6%96%AD%E4%B8%89%E8%A7%92%E5%BD%A2%E5%BD%A2%E7%8A%B6%E5%B9%B6%E8%AE%A1%E7%AE%97%E5%85%B6%E9%9D%A2%E7%A7%AF/","content":"利用 C\r\n语言实现已知三条边判断三角形形状并计算其面积\r\n同样是布置的一道课后思考的算法题，我就顺便把这道题给写出来了。主要是代码量有点庞大，顺便还写了个冒泡排序算法。\r\n这里简单介绍一下思路：\r\n如何判断三角形形状，这里用到了余弦定理 $$\r\n\\begin{flalign}\r\n\\cos C&amp;=\\frac{a^2+b^2-c^2}{2ab}\\\\\r\n当\\cos C&amp;&gt;0,为锐角三角形\\\\\r\n当\\cos C&amp;=0,为直角三角形\\\\\r\n当\\cos C&amp;&lt;0，为钝角三角形\\\\\r\n\\end{flalign}\r\n$$ 而分母 2ab &gt; 0\r\n恒成立，因此只需要判断分子 a2 + b2 − c2\r\n与 0 的大小关系即可。\r\n而这里就出现了一个问题，只需要一个角是直角或钝角，就是直角或钝角三角形，如果角\r\nC\r\n恰好是锐角就无法判断了吗？或者要判断三遍了吗？为了解决这个问题，这里我引入了排序算法，首先将序列\r\n(a, b, c)\r\n按照从小到大的顺序排列好，即消除其中的逆序对，就可以确定角 C\r\n为三角形中最大的角，有一个定理：大角对大边，那么当边\r\nc 最大时，角 C 也一定是最大的。\r\n然后是计算三角形面积的问题，已知三边求面积，这里有两个思路，一种是\r\n$$\r\n\\begin{flalign}\r\n\\cos C&amp;=\\frac{a^2+b^2-c^2}{2ab}\\\\\r\n\\sin C&amp;=\\sqrt{1-\\cos^2C}\\\\\r\nS&amp;=\\frac{1}{2}ab\\sin C\\\\\r\n\\end{flalign}\r\n$$ 其实是在计算 $\\frac{1}{2}\\left|\\vec{a}\\times\\vec{b}\\right|$，但这种方法被我淘汰了，因为可能出现大量的浮点数运算而且不够简洁。\r\n这里我想到了 Heron\r\n公式，又叫做秦九韶公式，专门用来计算已知三角形三边求面积的问题。 $$\r\n\\begin{flalign}\r\nS&amp;=\\sqrt{p(p-a)(p-b)(p-c)}\\\\\r\np&amp;=\\frac{a+b+c}{2}\\\\\r\n\\end{flalign}\r\n$$ 变得十分简洁了。\r\n\r\n下面直接给出全部代码。\r\n#include &lt;stdio.h&gt;#include &lt;math.h&gt;void sort(float *p)&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        for (int j = 0; j &lt; 2 - i; j++)        &#123;            float t = *(p + j);            if (t &gt; *(p + j + 1))            &#123;                *(p + j) = *(p + j + 1);                *(p + j + 1) = t;            &#125;        &#125;          &#125;&#125;short judge(float a, float b, float c)&#123;    if((a &lt;= 0) || (b &lt;= 0) || (c &lt;= 0))        return 0;    float side[3] = &#123;a, b, c&#125;;    sort(side);    a = side[0];    b = side[1];    c = side[2];    float delta = ((a * a) + (b * b) - (c * c));    if ((a + b &gt; c) &amp;&amp; (a - b &lt; c))    &#123;        if (delta &gt; 0)            return 1;        else if (delta == 0)            return 2;        else if (delta &lt; 0)            return 3;    &#125;    else        return 0;&#125;float calculate(float a, float b, float c)&#123;    float p = 0.5 * (a + b + c);    float area = sqrt(p * (p - a) * (p - b) * (p - c));    return area;&#125;int main()&#123;    float a, b, c;    scanf(&quot;%f %f %f&quot;, &amp;a, &amp;b, &amp;c);    switch (judge(a, b, c))    &#123;    case 0:        printf(&quot;Null\\n&quot;);        break;    case 1:        printf(&quot;Acute Triangle\\n&quot;);        break;    case 2:        printf(&quot;Right-angled Triangle\\n&quot;);        break;    case 3:        printf(&quot;Obtuse Triangle\\n&quot;);        break;    &#125;    printf(&quot;Area: %f&quot;, calculate(a, b, c));        return 0;&#125;\r\n\r\n排序算法-冒泡排序\r\n一切的一切要从排序说起\r\nvoid sort(float *p)&#123;    for (int i = 0; i &lt; 3; i++)    &#123;        for (int j = 0; j &lt; 2 - i; j++)        &#123;            float t = *(p + j);            if (t &gt; *(p + j + 1))            &#123;                *(p + j) = *(p + j + 1);                *(p + j + 1) = t;            &#125;        &#125;          &#125;&#125;\r\n一个简单的冒泡排序，首先选定元素 side[i]\r\n再从该元素后面选定各项元素 side[j] 与它比较大小，如果\r\nside[i] &gt; side[j]\r\n就让两元素交换位置，交换位置的算法也很简单，设定一个中间变量就可以。\r\n参数选择运用指针是为了让输入的数组直接在内存中就排好序，不用创建一个新的数组出来，节省内存同时提高运行效率。\r\n\r\n判断形状\r\nshort judge(float a, float b, float c)&#123;    if((a &lt;= 0) || (b &lt;= 0) || (c &lt;= 0))        return 0;    float side[3] = &#123;a, b, c&#125;;    sort(side);    a = side[0];    b = side[1];    c = side[2];    float delta = ((a * a) + (b * b) - (c * c));    if ((a + b &gt; c) &amp;&amp; (a - b &lt; c))    &#123;        if (delta &gt; 0)            return 1;        else if (delta == 0)            return 2;        else if (delta &lt; 0)            return 3;    &#125;    else        return 0;&#125;\r\n一开始先判断输入是否为正数，毕竟在 Euclid\r\n几何学内没有边长为负数的三角形（:smile:）。\r\n然后将三边放入数组调用排序函数。排完序后计算判别式 Δ = a2 + b2 − c2，不过首先要用定理两边之和大于第三边，两边之差小于第三边的定理来判断能否构成三角形。\r\n\r\n计算面积\r\nfloat calculate(float a, float b, float c)&#123;    float p = 0.5 * (a + b + c);    float area = sqrt(p * (p - a) * (p - b) * (p - c));    return area;&#125;\r\n没啥好说的，就是套用公式。本来我想自己整一个开平方根的算法，运用牛顿法求解，但是太懒了不想写，就扔给标准库了（😓）。\r\n","categories":["计算机程序设计(C)"],"tags":["编程","算法","C"]},{"title":"实数的完备性的几个定理证明","url":"/2025/10/15/%E5%AE%9E%E6%95%B0%E7%9A%84%E5%AE%8C%E5%A4%87%E6%80%A7%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E/","content":"实数的完备性的几个定理证明\r\n实数完备性的六个基本定理，这里记录一下其中几个证明。\r\n\r\n基本公理：Dedekind 基本定理\r\n\r\n表述1：对 ℝ 中任何非空子集 𝔸 和 𝔹，若\r\n∀a ∈ 𝔸, ∀b ∈ 𝔹, a ≤ b，则\r\n∃c ∈ ℝ, a ≤ c ≤ b.\r\n表述2：如果 ℝ\r\n两个子集满足如下性质：\r\n\r\n集合 𝔸 和 𝔹 都是非空的；\r\n𝔸 ∪ 𝔹 = ℝ；\r\n集合 𝔸 中的每一个数都小于 𝔹 中的任意一个数.\r\n这种分割 𝔸|𝔹\r\n称为一个戴德金分割，对于任意这种分割，都存在这个分割的实数 α，这个数或者是下组 𝔸 的最大数，或者是上组 𝔹 的最小数.\r\n\r\n\r\n定理一：确界原理\r\n\r\n非空有上(下)界数集必有其上(下)确界.\r\n\r\n定理二：单调有界收敛定理\r\n\r\n单调数列收敛的充要条件是其为有界数列，进一步地，当数列 an\r\n单调增时，$\\lim\\limits_{n \\to \\infty}a_n =\r\n\\sup{\\{a_n|n \\in N^*\\}}$，当数列 an\r\n单调减时，$\\lim\\limits_{n \\to \\infty} =\r\n\\inf{\\{a_n|n \\in N^*\\}}$.\r\n\r\n定理三：Cauchy 收敛准则\r\n\r\n数列收敛的充要条件是它为柯西数列.\r\n柯西数列定义：对于数列 an，满足 ∀ϵ &gt; 0, ∃N = N(ϵ) ∈ ℤ*, ∀m, n &gt; N，有\r\n|an − am| &lt; ϵ.\r\n\r\n定理四：区间套定理\r\n\r\n设有闭区间列 {[an, bn]}，满足条件：\r\n\r\n[a1, b1] ⊃ [a2, b2] ⊃ ⋯ ⊃ [an, bn] ⊃ ⋯;\r\n$\\lim\\limits_{n \\to \\infty} (b_n-a_n) =\r\n0$.\r\n\r\n则 ∃ 唯一的点 ξ，使得 $\\xi \\in \\bigcap_{n=1}^\\infty [a_n,b_n]$\r\n\r\n定理五：Bolzano 定理\r\n\r\n如果一个数列有界，那么他一定有一个收敛的子数列.\r\n\r\n定理六：Borel 有限覆盖定理\r\n\r\n如果开区间集合 𝕊 覆盖了闭区间 [a, b]，则 𝕊 中存在有限个开区间也覆盖了闭区间 [a, b]\r\n\r\n\r\n还有其他很多定理，这里先给出前五个定理之间的证明。\r\n\r\n\r\n确界原理 -&gt;\r\n单调有界收敛定理\r\n先假设数列 {an}\r\n单调增，|an| ≤ M, ∀n ∈ ℕ*，再假设集合\r\n𝔸 = {an|n ∈ ℕ*}.\r\n则 𝔸 有上界，由确界原理假设 sup 𝔸 = a. $$\r\n\\begin{flalign}\r\n&amp;\\forall \\epsilon &gt; 0, \\exists a_N \\in \\mathbb{A}, 使得 a_N &gt;\r\na - \\epsilon\\\\\r\n&amp;\\because \\{a_n\\}单调增，\\therefore \\forall n&gt;N, a \\geq a_n &gt;\r\na_N &gt; a - \\epsilon \\\\\r\n&amp;\\therefore \\left|a_n - a\\right| &lt; \\epsilon，\\therefore\r\n\\lim\\limits_{n \\to \\infty} a_n = a\r\n\\end{flalign}\r\n$$ 证毕。\r\n\r\n单调有界收敛定理 -&gt;\r\n区间套定理\r\n先证明存在性：\r\n假设数列 {an}\r\n单调增，{bn}\r\n单调减，an &lt; b1, bn &gt; a1，即\r\nan ≤ bn.\r\n$$\r\n\\begin{flalign}\r\n&amp;由单调有界收敛定理设，\\lim\\limits_{n \\to \\infty} a_n = \\xi,\r\n\\lim\\limits_{n \\to \\infty} b_n = \\lim\\limits_{n \\to \\infty} a_n +\r\n\\lim\\limits_{n \\to \\infty} (b_n-a_n) = \\xi \\\\\r\n&amp;又 a_n \\leq b_n，即 \\xi \\in [a_n,b_n] \\\\\r\n\\end{flalign}\r\n$$ 存在性证毕。\r\n再证明唯一性：\r\n若 ξ, η ∈ [an, bn]\r\n且 ξ ≠ η $$\r\n\\begin{flalign}\r\n&amp;b_n - a_n = \\left|\\xi - \\eta\\right| = \\tau &gt; 0\\\\\r\n&amp;发现与 \\lim\\limits_{n \\to \\infty} (b_n - a_n) = \\tau = 0 矛盾\r\n\\end{flalign}\r\n$$ 唯一性证毕。\r\n\r\n区间套定理 -&gt; Bolzano 定理\r\n若 a ≤ an ≤ b\r\n，∀apn.\r\n$$\r\n\\begin{flalign}\r\n1. &amp;记 c = \\frac{a + b}{2}，则 [a, c] 与 [c, b] 中至少有一个含有\r\n\\{a_n\\} 元素的无穷多项，记为 [a_2, b_2], \\\\\r\n   &amp;取 p_2 &gt; p_1，且 a_{p_2} \\in [a_2, b_2], b_2 - a_2 = \\frac{b\r\n- a}{2};\\\\\r\n2. &amp;类似的取 c_n = \\frac{a_n + b_n}{2}，则 [a_n, c_n] 与 [c_n, b_n]\r\n中也可以选取出无限多项 \\{a_n\\}，记为 [a_{n+1}, b_{n+1}], \\\\\r\n   &amp;取 p_{n+1} &gt; p_n，且 a_{p_{n+1}} \\in [a_{n+1},b_{n+1}],\r\nb_{n+1} - a_{n+1} = \\frac{b_n - a_n}{2}; \\\\\r\n综上&amp;，有子列 \\{a_{p_n} | n \\in \\mathbb{N^*} \\} 且 a_{p_n} \\in [a_n,\r\nb_n] \\\\\r\n[a_1&amp; b_1] \\supset [a_2, b_2] \\supset \\cdots \\supset [a_n, b_n]\r\n\\supset \\cdots, b_n - a_n = \\frac{1}{2^{n}}(b_1-a_1) \\\\\r\n\\lim\\limits_{n \\to \\infty}&amp; (b_n - a_n) = 0，由区间套定理得 \\xi \\in\r\n[a_n, b_n], \\lim\\limits_{n \\to \\infty}a_{p_n} = \\xi \\\\\r\n\\forall \\epsilon &amp;&gt; 0,\\exists N = \\left[\\log_2(\\frac{b_1 -\r\na_1}{\\epsilon})\\right] + 1, \\forall n &gt; N \\\\\r\n则 &amp;a_{p_n} \\in [a_n, b_n] \\subset \\cdots \\subset [a_N, b_N] 且\r\n\\epsilon \\in [a_N, b_N] \\\\\r\n&amp;\\left|a_n - \\xi\\right| &lt; \\left|b_N - a_N\\right| =\r\n\\frac{1}{2^N}(b_1 - a_1) &lt; \\epsilon \\\\\r\n&amp;即 \\lim\\limits_{n \\to \\infty} a_{p_n} = \\xi\r\n\\end{flalign}\r\n$$ 证毕。\r\n\r\nBolzano 定理 -&gt; Cauchy\r\n收敛定理\r\n设 {an}\r\n为 Cauchy 数列，可知该数列有界. $$\r\n\\begin{flalign}\r\n&amp;对于 \\epsilon = 1, \\exists N,使得 \\forall m, n &gt; N 有 |a_n -\r\na_m| &lt; \\epsilon = 1 \\\\\r\n&amp;即 |a_n| &lt; |a_m| + 1, \\forall n &gt; N, 故 |a_n| &lt;\r\n\\max\\{|a_1|, |a_2|, \\cdots, |a_N|, |a_m| + 1\\} \\\\\r\n&amp;由 Bolzano 定理得到,有子列 \\{a_{p_n}\\}, \\lim\\limits_{n \\to \\infty}\r\na_{p_n} = a \\\\\r\n&amp;\\forall \\epsilon &gt; 0, \\exists N_1, \\forall n &gt; N_1, 有\r\n|a_{p_n} - a| &lt; \\epsilon \\\\\r\n&amp;又该数列为 Cauchy 数列, \\exists N_2, \\forall m, n &gt; N_2, 有 |a_n\r\n- a_m| &lt; \\epsilon \\\\\r\n&amp;故，取 p_L &gt; N_2 且 p_L &gt; p_{N_1}, \\exists N = p_L, \\forall n\r\n&gt; N \\\\\r\n&amp;\\left|a_n - a\\right| &lt; \\left|a_n - a_{p_L} + a_{p_L} - a\\right|\r\n\\leq \\left|a_n - a_{p_L}\\right| + \\left|a_{p_L} - a\\right| &lt; \\epsilon\r\n+ \\epsilon = 2 \\epsilon \\\\\r\n&amp;即 \\lim\\limits_{n \\to \\infty} a_n = a\r\n\\end{flalign}\r\n$$ 证毕。\r\n\r\nCauchy 收敛定理 -&gt; 确界原理\r\n$$\r\n\\begin{flalign}\r\n假定, &amp;\\mathbb{E} 为非空集合且有上界 M, 且 \\mathbb{E} 无最大值 \\\\\r\n记 b_1&amp; 为 \\mathbb{E} 的一个上界, 且 b_1 = M, 取 \\forall a_1 \\in\r\n\\mathbb{E} \\\\\r\n取 c_1&amp; = \\frac{a_1 + b_1}{2}, 若 c_1 为 \\mathbb{E} 的上界，记 [a_1,\r\nc_1] 为 [a_2, b_2] \\\\\r\n&amp;否则记 [c_1, b_1] 为 [a_2, b_2] \\\\\r\n同理, &amp;记 c_n = \\frac{a_n + b_n}{2}, 若 C_n 为 \\mathbb{E} 的上界，记\r\n[a_n, c_n] 为 [a_{n + 1} , b_{n + 1}] \\\\\r\n&amp;否则记 [c_n, b_n] 为 [a_{n + 1}, b_{n + 1}] \\\\\r\n则 &amp;[a_{n+1}, b_{n+1}] \\subset [a_n, b_n] \\subset \\cdots \\subset\r\n[a_1, b_1], 且 \\frac{b_n - a_n}{2} = b_{n + 1} - a_{n + 1} \\\\\r\n又 &amp;b_n 为 \\mathbb{E} 的上界，a_{n+1} 不是 \\mathbb{E} 的上界 \\\\\r\n\\exists &amp;x \\in \\mathbb{E}, 使得 x \\geq a_{n + 1} \\\\\r\n设 a_{n + k} &amp;- a_n \\geq 0, k \\in \\mathbb{N^*} \\\\\r\na_{n + k} &amp;- a_n &lt; b_{n + k} - a_n \\leq b_n - a_n =\r\n\\frac{1}{2^n}(b_1 - a_1) \\\\\r\n&amp;0 \\leq b_n - b_{n + k} &lt; b_n -a_n = \\frac{1}{2^n}(b_1 - a_1) \\\\\r\n\\forall \\epsilon &gt; 0, &amp;\\exists N = \\left[\\log_2\\frac{b_1 -\r\na_1}{\\epsilon}\\right] + 1, \\forall n &gt; N \\\\\r\n&amp;|a_{n + k} - a_n| &lt; \\frac{1}{2^n}(b_1 - a_1) &lt;\r\n\\frac{1}{2^N}(b_1 - a_1) &lt; \\epsilon \\\\\r\n&amp;|b_n - b_{n + k}| &lt; \\epsilon \\\\\r\n则 \\{a_n\\}, &amp;\\{b_n\\} 均为 Cauchy 数列 \\\\\r\n先&amp;假设，\\lim\\limits_{n \\to \\infty} a_n = \\xi, \\lim\\limits_{n \\to\r\n\\infty} b_n = \\lim\\limits_{n \\to \\infty} a_n + \\lim\\limits_{n \\to\r\n\\infty} (b_n-a_n) = \\xi \\\\\r\n\\forall x \\in &amp;\\mathbb{E}, b_n 为 \\mathbb{E} 上界，对 n \\in\r\n\\mathbb{N^*} \\\\\r\n\\forall n 有&amp; x \\leq b_n，即 x \\leq \\lim\\limits_{n \\to \\infty} b_n =\r\n\\xi, 故 \\xi 为 \\mathbb{E} 的上界 \\\\\r\n\\forall \\epsilon &gt;&amp; 0, \\exists N, 对 n &gt; N, |a_n - \\xi| &lt;\r\n\\epsilon, 即 -\\epsilon &lt; a_n - \\xi &lt; \\epsilon \\\\\r\n&amp;可改写为 a_n \\geq a_{N + 1} &gt; \\xi - \\epsilon \\\\\r\n\\therefore \\exists x \\in &amp;\\mathbb{E}, 使得 x \\geq a_{N + 1} &gt; \\xi\r\n- \\epsilon \\\\\r\n综上 \\sup &amp;\\mathbb{E} = \\xi\r\n\\end{flalign}\r\n$$\r\n证毕。\r\n","categories":["微积分I"],"tags":["数学","微积分","极限"]},{"title":"来一些不等式、恒等式、定理的证明","url":"/2025/10/06/%E6%9D%A5%E4%B8%80%E4%BA%9B%E4%B8%8D%E7%AD%89%E5%BC%8F%E3%80%81%E6%81%92%E7%AD%89%E5%BC%8F%E3%80%81%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E/","content":"来一些不等式、恒等式、定理的证明\r\n最近翻到了这些不等式、恒等式、定理这些东西，害怕忘掉这里简要记录一下。\r\n首先先说明下这些定理。\r\n\r\nChebyshev 不等式\r\n\r\n对于序列 a1 ≤ a2 ≤ ⋯ ≤ an, b1 ≤ b2 ≤ ⋯ ≤ bn，则有：\r\n\r\n$$\r\n\\begin{flalign}\r\n\\left(\\sum_{i=1}^na_i\\right)\\left(\\sum_{j=1}^nb_j\\right)\\leq\r\nn\\sum_{k=1}^na_kb_k\r\n\\end{flalign}\r\n$$\r\nCauchy 不等式\r\n\r\n设两组实数 x1, x2, ⋯, xn\r\n和 y1, y2, ⋯, yn，则有：\r\n\r\n$$\r\n\\begin{flalign}\r\n\\left(\\sum_{i=1}^nx_iy_i\\right)^2\\leq\\left(\\sum_{i=1}^nx_i^2\\right)\\left(\\sum_{i=1}^ny_i^2\\right)\r\n\\end{flalign}\r\n$$\r\nAbel 恒等式\r\n\r\n记 $B_0=0,B_n=\\sum_{i=1}^nb_i$，则： $$\r\n\\begin{flalign}\r\nS_n=\\sum_{i=1}^na_ib_i=B_na_n-\\sum_{i=1}^{n-1}B_i(a_{i+1}-a_i)\r\n\\end{flalign}\r\n$$\r\n\r\n二项式定理\r\n\r\n对 ∀x ∈ ℝ, n ∈ ℕ*，有：\r\n\r\n$$\r\n\\begin{flalign}\r\n(1+x)^n=\\sum_{i=0}^n{n\\choose i}x^i\r\n\\end{flalign}\r\n$$\r\n推广的 Bernoulli 不等式\r\n\r\n若 ai &gt; −1, 1 ≤ i ≤ n, i ∈ ℕ*\r\n且同号，则有：\r\n\r\n$$\r\n\\begin{flalign}\r\n\\prod_{i=1}^n(1+a_i)\\geq1+\\sum_{i=1}^na_i\r\n\\end{flalign}\r\n$$\r\nHölder 不等式\r\n\r\n设两组非负实数 x1, x2, ⋯, xn\r\n和 y1, y2, ⋯, yn，并设\r\n$p,q&gt;1,\\frac{1}{p}+\\frac{1}{q}=1$，则有：\r\n\r\n$$\r\n\\begin{flalign}\r\n\\sum_{i=1}^nx_iy_i\\leq\\left(\\sum_{i=1}^nx_i^p\\right)^\\frac{1}{p}\\left(\\sum_{j=1}^ny_j^q\\right)^\\frac{1}{q}\r\n\\end{flalign}\r\n$$\r\n\r\n\r\n\r\n证明 Chebyshev 不等式\r\n我们先构建一个神奇的不等式：\r\n∑1 ≤ j &lt; i ≤ n(ai − aj)(bi − bj) ≥ 0，令\r\nS = ∑1 ≤ j &lt; i ≤ n(ai − aj)(bi − bj) ≥ 0\r\n$$\r\n\\begin{flalign}\r\n2S&amp;=\\sum_{1\\leq j&lt;i\\leq n}(a_i-a_j)(b_i-b_j)+\\sum_{1\\leq\r\ni&lt;j\\leq n}(a_i-a_j)(b_i-b_j)+0\\\\\r\n&amp;=\\sum_{1\\leq j&lt;i\\leq n}(a_i-a_j)(b_i-b_j)+\\sum_{1\\leq i&lt;j\\leq\r\nn}(a_i-a_j)(b_i-b_j)+\\sum_{1\\leq i=j\\leq n}(a_i-a_j)(b_i-b_j)\\\\\r\n&amp;=\\sum_{i,j=1}^n(a_i-a_j)(b_i-b_j)\\\\\r\n&amp;=\\sum_{i,j=1}^n(a_ib_i+a_jb_j-a_ib_j-a_jb_i)\\\\\r\n&amp;=\\sum_{i,j=1}^na_ib_i+\\sum_{i,j=1}^na_jb_j-\\sum_{i,j=1}^na_ib_j-\\sum_{i,j=1}^na_jb_i\\\\\r\n&amp;=n\\sum_{i=1}^na_ib_i+n\\sum_{j=1}^na_jb_j-2\\sum_{i,j=1}^na_ib_j\\\\\r\n&amp;=2n\\sum_{k=1}^na_kb_k-2\\left(\\sum_{i=1}^na_i\\right)\\left(\\sum_{j=1}^nb_j\\right)\\\\\r\n&amp;\\geq0\\\\\r\n即有，&amp;n\\sum_{k=1}^na_kb_k-\\left(\\sum_{i=1}^na_i\\right)\\left(\\sum_{j=1}^nb_j\\right)\\geq0\\\\\r\n可化为，&amp;\\left(\\sum_{i=1}^na_i\\right)\\left(\\sum_{j=1}^nb_j\\right)\\leq\r\nn\\sum_{k=1}^na_kb_k\r\n\\end{flalign}\r\n$$ 证毕。\r\n\r\n证明 Cauchy 不等式\r\n我们先构建关于 t\r\n的二次不等式 $\\sum_{i=0}^n(x_it+y_i)^2\\geq0$ $$\r\n\\begin{flalign}\r\n&amp;\\sum_{i=0}^n(x_it+y_i)^2\\\\\r\n=&amp;\\sum_{i=0}^n(x_i^2t^2+2x_iy_it+y_i^2)\\\\\r\n=&amp;t^2\\sum_{i=0}^nx_i^2+2t\\sum_{i=0}^nx_iy_i+\\sum_{i=0}^ny_i^2\\\\\r\n\\geq&amp;0\r\n\\\\\\\\\r\n\\Delta=&amp;4(\\sum_{i=0}^nx_iy_i)^2-4(\\sum_{i=0}^nx_i^2)(\\sum_{i=0}^ny_i^2)\\leq0\\\\\r\n即&amp;\\left(\\sum_{i=1}^nx_iy_i\\right)^2\\leq\\left(\\sum_{i=1}^nx_i^2\\right)\\left(\\sum_{i=1}^ny_i^2\\right)\r\n\\end{flalign}\r\n$$ 证毕。\r\n注：在高中课后习题中还有一个利用 n\r\n维向量的内积证明的办法，以后在更新（咕咕咕）。\r\n\r\n证明 Abel 恒等式\r\n没什么花里胡哨的，直接开证： $$\r\n\\begin{flalign}\r\nS&amp;=\\sum_{i=1}^na_ib_i=\\sum_{i=1}^na_i(B_i-B_{i-1})\\\\\r\n&amp;=\\sum_{i=1}^na_iB_i-\\sum_{i=1}^na_iB_{i-1}\\\\\r\n&amp;=a_nB_n+\\sum_{i=1}^{n-1}a_iB_i-\\sum_{i=0}^{n-1}a_{i+1}B_i\\\\\r\n&amp;=a_nB_n+\\sum_{i=1}^{n-1}a_iB_i-\\sum_{i=1}^{n-1}a_{i+1}B_i-a_1B_0\\\\\r\n&amp;=a_nB_n+\\sum_{i=1}^{n-1}a_iB_i-\\sum_{i=1}^{n-1}a_{i+1}B_i-0\\\\\r\n&amp;=a_nB_n+\\sum_{i=1}^{n-1}B_i(a_i-a_{i+1})\r\n\\end{flalign}\r\n$$ 证毕。\r\n\r\n证明二项式定理\r\n运用数学归纳法。\r\n当 n = 1，n = 2\r\n时，显然成立.\r\n假设对于 n − 1\r\n成立，则推理对于 n 也成立即可.\r\n$$\r\n\\begin{flalign}\r\n(1+x)^n&amp;=(1+x)(1+x)^{n-1}=(1+x)\\sum_{k=0}^{n-1}{n-1 \\choose k}x^k\\\\\r\n&amp;=\\sum_{k=0}^{n-1}{n-1 \\choose k}x^k+\\sum_{k=0}^{n-1}{n-1 \\choose\r\nk}x^{k+1}\\\\\r\n&amp;=\\sum_{k=1}^{n-1}{n-1 \\choose k}x^k+\\sum_{k=1}^{n-1}{n-1 \\choose\r\nk-1}x^k+1+x^n\\\\\r\n&amp;=\\sum_{k=1}^{n-1}\\left({n-1 \\choose k}+{n-1 \\choose\r\nk-1}\\right)x^k+1+x^n\\\\\r\n&amp;=\\sum_{k=1}^{n-1}{n \\choose k}x^k+1+x^n=\\sum_{k=0}^n{n \\choose\r\nk}x^k\r\n\\end{flalign}\r\n$$ 则对于 n 也成立.\r\n证毕。\r\n\r\n证明推广的 Bernoulli 不等式\r\n运用数学归纳法。\r\n当 n = 1 时，有 1 + a1 = 1 + a1.\r\n当 n = 2 时，有 (1 + a1)(1 + a2) = 1 + a1 + a2 + a1a2 &gt; 1 + a1 + a2.\r\n假设 n = k\r\n时，该不等式仍然成立，则证明 n = k + 1 时也成立即可：\r\n$$\r\n\\begin{flalign}\r\n\\prod_{i=1}^{k+1}(1+a_i)&amp;=(1+a_{k+1})\\cdot\\prod_{i=1}^{k}(1+a_i)\\geq(1+a_{k+1})(1+\\sum_{i=1}^ka_i)\\\\\r\n&amp;=1+\\sum_{i=1}^ka_i+a_{k+1}+a_{k+1}\\sum_{i=1}^ka_i\\\\\r\n&amp;\\geq1+\\sum_{i=1}^{k+1}a_i\r\n\\end{flalign}\r\n$$ 则对于 n = k + 1 也成立.\r\n证毕。\r\n\r\n证明 Hölder 不等式\r\n发现所有的证明都要用到 Young 不等式，而 Young\r\n不等式又要用加权平均值不等式证明。\r\n好麻烦（😓）。\r\n\r\n证明加权平均值不等式\r\n这里只需要有理数的序列即可，令 $w_i=\\frac{p_i}{q}$. $$\r\n\\begin{flalign}\r\n\\sum_{i=1}^nw_ix_i&amp;=\\sum_{i=1}^n\\frac{p_i}{q}x_i=\\frac{1}{q}\\sum_{i=1}^np_ix_i\\\\\r\n&amp;\\geq\\sqrt[q]{\\prod_{i=1}^nx_i^{p_i}}=\\prod_{i=1}^nx_i^{\\frac{p_i}{q}}=\\prod_{i=1}^nx_i^{w_i}\r\n\\end{flalign}\r\n$$ 有理数的加权平均值不等式证毕。\r\n这里给张详细证明的截图，来自知乎的第一条回答。\r\n\r\n\r\n证明 Young 不等式\r\n这里定义 $\\frac{1}{p}+\\frac{1}{q}=1$.\r\n当 ab = 0\r\n时，结论显然成立. $$\r\n\\begin{flalign}\r\n\\frac{a^p}{p}+\\frac{b^q}{q}\\geq\\sqrt[p]{a^p}\\sqrt[q]{b^q}=ab\r\n\\end{flalign}\r\n$$ 有理数时的 Young 不等式证毕。\r\n详细证明参考百度百科。\r\n\r\n证明 Hölder 不等式\r\n令 $A=\\left(\\sum_{i=1}^nx_i^p\\right)^\\frac{1}{p},B=\\left(\\sum_{i=1}^ny_i^q\\right)^\\frac{1}{q},a_i=\\frac{x_i}{A},b_i=\\frac{y_i}{B}$.\r\n$$\r\n\\begin{flalign}\r\n&amp;a_ib_i\\leq\\frac{a^p}{p}+\\frac{b^q}{q}=\\frac{\\frac{x_i^p}{\\sum_{i=1}^nx_i^p}}{p}+\\frac{\\frac{y_i^q}{\\sum_{i=1}^ny_i^q}}{q}\\\\\r\n&amp;\\sum_{i=1}^na_ib_i=\\frac{\\sum_{i=1}^nx_iy_i}{AB}\\leq\\frac{\\frac{\\sum_{i=1}^nx_i^p}{\\sum_{i=1}^nx_i^p}}{p}+\\frac{\\frac{\\sum_{i=1}^ny_i^q}{\\sum_{i=1}^ny_i^q}}{q}=\\frac{1}{p}+\\frac{1}{q}=1\\\\\r\n&amp;\\sum_{i=1}^nx_iy_i\\leq\r\nAB=\\left(\\sum_{i=1}^nx_i^p\\right)^\\frac{1}{p}\\left(\\sum_{j=1}^ny_j^q\\right)^\\frac{1}{q}\r\n\\end{flalign}\r\n$$ 证毕。\r\n","categories":["线性代数"],"tags":["数学"]},{"title":"利用 C 语言实现简单的凯撒密码","url":"/2025/10/10/%E5%88%A9%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81/","content":"利用 C\r\n语言实现简单的凯撒密码\r\n布置的一道扩展题，用于实现凯撒加密。\r\n凯撒密码就是一个简单的替换加密，这里题设 key: 'A' = 'D'\r\n所以不需要再搞 key\r\n这一块。我的算法比网上某些转换器精准一点，可以无损转所有的 ASCII\r\n字符，同时跳过所有非 ASCII 字符。\r\n最重头戏的是我搞了一个可变长度的 *buffer\r\n用于存放字符串，这是我第一次尝试搞内存上的编程，先抄了网上的作业。\r\n\r\n惯例，先上代码！\r\n#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;static char *buffer = NULL;void get_input()&#123;    size_t size = 0;    size_t len = 0;    char temp;    while (1)    &#123;        if (len &gt;= size)        &#123;            size_t n_size = (size == 0) ? 5 : size * 5;            buffer = (char *) realloc(buffer, n_size);                        if (buffer == NULL)            &#123;                free(buffer);            &#125;                        size = n_size;        &#125;        if (scanf(&quot;%c&quot;, &amp;temp) != 1)        &#123;            break;        &#125;        buffer[len++] = temp;        if(temp == &#x27;\\n&#x27;)        &#123;            buffer[len] = &#x27;\\0&#x27;;            break;        &#125;    &#125;&#125;void convert(char *str)&#123;    for (int i = 0; str[i] != 0; i++)    &#123;        if ((str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) || (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;))        &#123;            if ((str[i] &gt;= &#x27;x&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) || (str[i] &gt;= &#x27;X&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;))            &#123;                str[i] = (char) (str[i] - (&#x27;x&#x27; - &#x27;a&#x27;));                continue;            &#125;                        str[i] = (char) (str[i] + (&#x27;d&#x27; - &#x27;a&#x27;));        &#125;    &#125;&#125;int main()&#123;    get_input();        convert(buffer);    for (int i = 0; buffer[i] != 0; i++)    &#123;        printf(&quot;%c&quot;, buffer[i]);    &#125;    free(buffer);    return 0;&#125;\r\n\r\n可变长度字符串\r\nstatic char *buffer = NULL;void get_input()&#123;    size_t size = 0;    size_t len = 0;    char temp;    while (1)    &#123;        if (len &gt;= size)        &#123;            size_t n_size = (size == 0) ? 5 : size * 5;            buffer = (char *) realloc(buffer, n_size);                        if (buffer == NULL)            &#123;                free(buffer);            &#125;                        size = n_size;        &#125;        if (scanf(&quot;%c&quot;, &amp;temp) != 1)        &#123;            break;        &#125;        buffer[len++] = temp;        if(temp == &#x27;\\n&#x27;)        &#123;            buffer[len] = &#x27;\\0&#x27;;            break;        &#125;    &#125;&#125;\r\n这个函数用于获取输入，同时根据输入长度改变字符串长度。\r\n我需要慢慢解释一下：\r\nstatic char *buffer = NULL;\r\n先定义了一个静态的全局字符型指针\r\n*buffer，先让这个指针悬空，把这个指针存栈里面。定义全局是为了在\r\nmain() 中最后释放内存。\r\nsize_t size = 0;size_t len = 0;char temp;\r\n定义了 3 个变量\r\nsize，len，temp，其中\r\nsize 和 len 为 size_t\r\n类型，这和内存分配有关，其中 size\r\n负责字符串容量，len 负责字符串的长度，当长度太长时主动扩大\r\nsize ，分配更多内存。char temp\r\n这个字符型变量负责逐个读取输入，并将输入塞进 *buffer\r\n指向的堆里面。\r\n随后定义一个 while 死循环，不断进行操作，在最后选择\r\nbreak\r\n跳出，一般经常用这种方式写一些持续时间长的代码，比如我曾经在 Java\r\n里用这种方式搞了一个 Socket 服务器，也是利用\r\nwhile 死循环，catch 到异常时跳出。\r\nif (len &gt;= size)&#123;\tsize_t n_size = (size == 0) ? 5 : size * 5;\tbuffer = (char *) realloc(buffer, n_size);            \tif (buffer == NULL)\t&#123;\t\tfree(buffer);\t&#125;            \tsize = n_size;&#125;\r\n这串是负责分配内存的主要代码，第一个 if\r\n用于判断是否需要扩容，即字符串的长度比字符串本身还大或两个一样大了的情况有没有发生。如果有，进行扩容。\r\nsize_t n_size = (size == 0) ? 5 : size * 5;buffer = (char *) realloc(buffer, n_size);\r\n定义了一个 n_size，就是我们下面要扩容的容量，这里说一下\r\nrealloc() 函数。\r\n翻一下 &lt;malloc.h&gt; 中的定义可以发现：\r\nvoid *__cdecl realloc(void *_Memory,size_t _NewSize);\r\n返回值是一个 void * 指针，所以赋值给 buffer\r\n时要强制类型转换为\r\nchar *。函数中有两个参数，_Memory 和\r\n_NewSize，分别是指要重分配的内存地址和容量大小。这里选择扩容\r\n*buffer，容量为 n_size。\r\nif (buffer == NULL)&#123;\tfree(buffer);&#125;\r\n判断一个异常情况，也就是没法正确重分配内存或者根本没有输入，提前释放内存避免内存异常，同时可以\r\nprintf() 一些报错，但是我懒得写了。😅\r\nsize = n_size;\r\n将 size 刷新为新容量。\r\nif (scanf(&quot;%c&quot;, &amp;temp) != 1)&#123;\tbreak;&#125;\r\n这里用到了一个 scanf() 的特性，翻一下\r\n&lt;stdio.h&gt; 发现：\r\nint __cdecl scanf(const char * __restrict__ _Format,...);\r\n返回值居然是一个 int\r\n类型，也就是返回值说明了这个函数是否执行成功，也就是我们用于这里将其放在\r\nif\r\n中的原因，同时判断输入合法情况与把读取一个输入的字符给放到一起了，挺好。\r\n同时 scanf(\"%c\", &amp;temp)\r\n还有一个特性，我们输入的内容都将进入缓冲区，函数每次会从缓冲区中读取任何一个字符，包括空格和换行，这时\r\n%c 独有的。比如我输入了 Razor sax，把这个\r\nscanf(\"%c\", &amp;temp) 放到一个循环里面，首先\r\nRazor sax 会进入缓冲区，随后函数读取缓冲区的一个字符\r\n'R'，此时 temp = 'R'，并将 'R'\r\n字符从缓冲区中移除，循环再次运行到这里时，缓冲区只剩下了\r\nazor sax，同理继续读取。\r\nbuffer[len++] = temp;if(temp == &#x27;\\n&#x27;)&#123;\tbuffer[len] = &#x27;\\0&#x27;;\tbreak;&#125;\r\nbuffer[len++] = temp\r\n也是一个很好的写法，同时实现了两个功能，即\r\nbuffer[len] = temp，和\r\nlen++，这样将每次读取的字符存到 *buffer\r\n指向的堆区域，这样 *buffer != NULL\r\n了，字符串也就存进去了。\r\n后面的 if 判断是否输入了回车，回车就结束输入，并且按照 C\r\n语言的特性将字符串末尾换成\r\n'\\0'，方便进行判断是否遍历到头。\r\n最后不要忘了在 main() 里面把 *buffer\r\n指向的内存给释放了。\r\n\r\n替换加密\r\nvoid convert(char *str)&#123;    for (int i = 0; str[i] != 0; i++)    &#123;        if ((str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) || (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;))        &#123;            if ((str[i] &gt;= &#x27;x&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) || (str[i] &gt;= &#x27;X&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;))            &#123;                str[i] = (char) (str[i] - (&#x27;x&#x27; - &#x27;a&#x27;));                continue;            &#125;                        str[i] = (char) (str[i] + (&#x27;d&#x27; - &#x27;a&#x27;));        &#125;    &#125;&#125;\r\n这部分就比较简单了，就是许多条件判断而已。\r\n首先遍历字符串，这里我们把末尾换成 '\\0'\r\n的好处就出现了，遍历很方便。首先判断是不是 ASCII\r\n中的字母，不是就不要管，然后判断是不是三个特殊的字母\r\nx, y, z，因为 A = D，所以\r\nx, y, z = a, b, c，如果有一个环形的数据结构就好了~就不用选择这些特殊字符了，或许可以用环形链表，这样就好搞了。之后试着优化一下代码。\r\n\r\n测试\r\n输入了小岛秀夫（随便想的一个，Salute to Kojima）的英文 wiki\r\n简介看看结果，原文：\r\n\r\nHideo Kojima (Kojima Hideo; born August 24,\r\n1963) is a Japanese video game designer, writer, director, and producer.\r\nHis games are noted for being highly cinematic, the result of a passion\r\nfor film and literature which began during his childhood, and he is\r\nregarded as a pioneering auteur* of video\r\ngames.[1] He\r\nis known for the Metal Gear\r\nfranchise, which remains his most famous and acclaimed work, as well\r\nas Death\r\nStranding and its\r\nsequel.\r\nUpon joining Konami in 1986, Kojima\r\ndirected, designed, and wrote Metal\r\nGear (1987) for the MSX2. The game laid the\r\nfoundation for the stealth game genre\r\nand the renowned Metal Gear franchise, which he continued to\r\nhelm up to the release of Metal\r\nGear Solid V (2015). During his time at Konami, he also\r\nproduced the Zone of the\r\nEnders series, as well as designing and writing Snatcher\r\n(1988) and Policenauts\r\n(1994); these were graphic\r\nadventure games that came to be regarded for their cinematic\r\npresentation.\r\nKojima founded Kojima\r\nProductions within Konami in 2005, and was appointed vice president\r\nof Konami\r\nDigital Entertainment in 2011. Following the controversial\r\ncancellation of his project, Silent Hills, and\r\nhis departure from Konami in 2015, he re-established Kojima Productions\r\nas an independent studio and released his first games outside Konami\r\nwith Death\r\nStranding (2019) and Death\r\nStranding 2: On the Beach (2025). The first game received\r\nmostly positive reviews, while its sequel received widespread\r\nacclaim.\r\n\r\n加密后：\r\n\r\nKlghr Nrmlpd (Nrmlpd Klghr; eruq Dxjxvw 24,\r\n1963) lv d Mdsdqhvh ylghr jdph ghvljqhu, zulwhu, gluhfwru, dqg surgxfhu.\r\nKlv jdphv duh qrwhg iru ehlqj kljkob flqhpdwlf, wkh uhvxow ri d sdvvlrq\r\niru ilop dqg olwhudwxuh zklfk ehjdq gxulqj klv fklogkrrg, dqg kh lv\r\nuhjdughg dv d slrqhhulqj dxwhxu* ri ylghr\r\njdphv.[1] Kh\r\nlv nqrzq iru wkh Phwdo Jhdu\r\niudqfklvh, zklfk uhpdlqv klv prvw idprxv dqg dffodlphg zrun, dv zhoo\r\ndv Ghdwk\r\nVwudqglqj dqg lwv\r\nvhtxho.Xsrq mrlqlqj Nrqdpl lq 1986, Nrmlpd\r\ngluhfwhg, ghvljqhg, dqg zurwh Phwdo\r\nJhdu (1987) iru wkh PVA2. Wkh jdph odlg wkh\r\nirxqgdwlrq iru wkh vwhdowk jdph jhquh\r\ndqg wkh uhqrzqhg Phwdo Jhdu iudqfklvh, zklfk kh frqwlqxhg wr\r\nkhop xs wr wkh uhohdvh ri Phwdo\r\nJhdu Vrolg Y (2015). Gxulqj klv wlph dw Nrqdpl, kh dovr\r\nsurgxfhg wkh Crqh ri wkh\r\nHqghuv vhulhv, dv zhoo dv ghvljqlqj dqg zulwlqj Vqdwfkhu\r\n(1988) dqg Srolfhqdxwv\r\n(1994); wkhvh zhuh judsklf\r\ndgyhqwxuh jdphv wkdw fdph wr eh uhjdughg iru wkhlu flqhpdwlf\r\nsuhvhqwdwlrq.Nrmlpd irxqghg Nrmlpd\r\nSurgxfwlrqv zlwklq Nrqdpl lq 2005, dqg zdv dssrlqwhg ylfh suhvlghqw\r\nri Nrqdpl\r\nGljlwdo Hqwhuwdlqphqw lq 2011. Iroorzlqj wkh frqwuryhuvldo\r\nfdqfhoodwlrq ri klv surmhfw, Vlohqw Kloov, dqg\r\nklv ghsduwxuh iurp Nrqdpl lq 2015, kh uh-hvwdeolvkhg Nrmlpd Surgxfwlrqv\r\ndv dq lqghshqghqw vwxglr dqg uhohdvhg klv iluvw jdphv rxwvlgh Nrqdpl\r\nzlwk Ghdwk\r\nVwudqglqj (2019) dqg Ghdwk\r\nVwudqglqj 2: Rq wkh Ehdfk (2025). Wkh iluvw jdph uhfhlyhg\r\nprvwob srvlwlyh uhylhzv, zkloh lwv vhtxho uhfhlyhg zlghvsuhdg\r\ndffodlp.\r\n\r\n甚至连粗体这些样式都保留的差不多。\r\n\r\n后续代码优化\r\n2025.10.12 更新\r\n发现用环状链表的代码效率简直就是依托，还不如之前的字符运算，优化下算法就行了。\r\n代码还在 todo（新建文件中。。。）\r\n","categories":["计算机程序设计(C)"],"tags":["编程","算法","C"]},{"title":"证明 Binet-Cauchy 公式","url":"/2025/10/16/%E8%AF%81%E6%98%8E-Binet-Cauchy-%E5%85%AC%E5%BC%8F/","content":"证明 Binet-Cauchy 公式\r\n定义矩阵 A 与 B，则有\r\n\r\n若 A, B ∈ 𝔽𝕟 × 𝕟，则\r\ndet AB = det A ⋅ det B；\r\n若 A ∈ 𝔽𝕞 × 𝕟, B ∈ 𝔽𝕟 × 𝕞, m &gt; n，则\r\ndet AB = 0；\r\n若 A ∈ 𝔽𝕞 × 𝕟, B ∈ 𝔽𝕟 × 𝕞, m ≤ n，则\r\ndet AB = ∑Sdet AS ⋅ det BS，其中\r\nS 是 {1, 2, ⋯, n} 的一个含有 m 个元素的子集遍历，AS 为 A 的一个 m × m 子矩阵。\r\n\r\n以上称为 Binet-Cauchy 公式。\r\n\r\n这里只证明第一种情况，运用两种方法。\r\n\r\n法一：行列式完全展开式\r\n由于显示问题，我只能将完整的过程分成几部分展示出。\r\n$$ $$\r\n\r\n（以上为第一部分证明；）\r\n\r\n$$\r\n\\begin{flalign}\r\n&amp; 利用行列式的多重线性相关性，即将每一个元素补充为\r\n\\sum_{k_1,k_2,\\cdots,k_n=1}^n a_{1k_1} a_{2k_2} \\cdots a_{nk_n} B_{k_i}\r\n\\\\\\\\\r\n&amp; 此时行列式的值不变，同时提取出公因式 \\sum_{k_1,k_2,\\cdots,k_n=1}^n\r\na_{1k_1} a_{2k_2} \\cdots a_{nk_n} \\\\\\\\\r\n&amp; 则 \\det{AB} = \\sum_{k_1,k_2,\\cdots,k_n=1}^n a_{1k_1} a_{2k_2}\r\n\\cdots a_{nk_n} \\det \\left(\r\n        \\begin{matrix}\r\n            B_1 &amp; B_2 &amp; \\cdots &amp; B_n\r\n        \\end{matrix}\r\n    \\right) \\\\\\\\\r\n&amp; 这里序列 (k_1,k_2,\\cdots,k_n) (1 \\leq k_1, k_2, \\cdots, k_n \\leq\r\nn) \\\\\r\n&amp; 可以映射至有序序列 (j_1, j_2, \\cdots, j_n)(1 \\leq j_1 &lt; j_2\r\n&lt; \\cdots &lt; j_n \\leq n)\r\n\\end{flalign}\r\n$$\r\n\r\n（以上为第二部分证明；）\r\n\r\n$$\r\n\\begin{flalign}\r\n&amp; 则定义 (j_1, j_2, \\cdots, j_n) \\in S_n，其中 S_n 为\r\n(k_1,k_2,\\cdots,k_n)，即为 (j_1, j_2, \\cdots, j_n) 的各种排列形式 \\\\\\\\\r\n&amp; 可视为 \\det{AB} = \\sum_{(j_1, j_2, \\cdots, j_n) \\in S_n} a_{1j_1}\r\na_{2j_2} \\cdots a_{nj_n} \\det \\left(\r\n        \\begin{matrix}\r\n            B_1 &amp; B_2 &amp; \\cdots &amp; B_n\r\n        \\end{matrix}\r\n    \\right) \\\\\\\\\r\n&amp;\r\n要得到最后的结果，要将所有的逆排列计入求和情况，这些情况要计算逆序数\r\n\\tau(j)，就可以囊括 (k_1,k_2,\\cdots,k_n) \\\\\r\n&amp; 这些逆序数要计算入结果需要 (-1)^{\\tau(j)} \\\\\\\\\r\n&amp; det{AB} = \\sum_{(j_1, j_2, \\cdots, j_n) \\in S_n} a_{1j_1} a_{2j_2}\r\n\\cdots a_{nj_n} (-1)^{\\tau(j)} \\det \\left(\r\n        \\begin{matrix}\r\n            B_1 &amp; B_2 &amp; \\cdots &amp; B_n\r\n        \\end{matrix}\r\n    \\right) \\\\\\\\\r\n&amp; 又 \\sum_{(j_1, j_2, \\cdots, j_n) \\in S_n} a_{1j_1} a_{2j_2} \\cdots\r\na_{nj_n} (-1)^{\\tau(j)} 为 \\det{A} 的完全展开式 \\\\\\\\\r\n&amp; 则 \\det{AB} = \\det{A} \\det{B}\r\n\\end{flalign}\r\n$$\r\n证毕。\r\n\r\n法二：利用初等变换矩阵\r\n前置知识\r\n初等变换共有三种：\r\n\r\n交换矩阵中的第 i, j\r\n行或列，行列式取相反数；\r\n矩阵第 i 行或列乘因数\r\na，行列式乘 a；\r\n矩阵第 j 行或列乘因数\r\na 后加到第 i 行或列，行列式不变。\r\n\r\n这些初等变换都可以利用矩阵乘法表示，具有这些性质的矩阵叫做初等矩阵：与其他矩阵相乘可以产生初等变换。\r\n上面的三种情况分别对应矩阵 Pij，Di(a)，Tij(a)。\r\n用实例表示，PijA\r\n表示交换 i, j\r\n两行，BPij\r\n表示交换 i, j\r\n两列。其余同理。\r\n下面以 Pij\r\n为例说明交换 i, j\r\n两行是如何做到的。 $$\r\n\\begin{flalign}\r\n&amp; I_n 为 n 阶单位阵，出对角线为 1 外其余位置全部为 0 \\\\\r\n&amp; E_{ij} 为一个特殊的矩阵，它的第 i 行第 j 列为 1，其余位置都是 0 \\\\\r\n&amp; 定义 P_{ij} = I_n - E_{ii} - E_{jj} + E_{ij} + E_{ji} \\\\\r\n&amp; 则举一个例子 P_{ij}A = I_nA - E_{ii}A - E_{jj}A + E_{ij}A +\r\nE_{ji}A \\\\\r\n&amp; I_nA 没有改变任何东西，仍为 A \\\\\r\n&amp; E_{ii}A 清除到只剩 A 的第 i 行，I_nA - E_{ii}A 删除了 A 的第 i 行\r\n\\\\\r\n&amp; E_{jj}A 清除到只剩 A 的第 j 行，I_nA - E_{ii}A - E_{jj}A 删除了 A\r\n的第 i, j 行 \\\\\r\n&amp; E_{ij}A 将第 i 行放到了第 j 行，E_{ji}A将第 j 行放在了第 i 行 \\\\\r\n&amp; 由此实现了交换了第 i,j 行\r\n\\end{flalign}\r\n$$\r\n\r\n实际证明\r\n\r\n当 det A ≠ 0 时\r\n\r\n$$\r\n\\begin{flalign}\r\n&amp; 此时任意的 A 都可以由一个单位阵通过任意次初等变换得到 \\\\\r\n&amp; 可记 A = P_1 P_2 \\cdots P_r，(P_1, P_2, \\cdots P_r 为初等矩阵) \\\\\r\n&amp; \\det{AB} = \\det{(P_1 P_2 \\cdots P_r B)} = \\det{P_1} \\det{P_2}\r\n\\cdots \\det{P_r} \\det B \\\\\r\n&amp;= \\det{(P_1, P_2, \\cdots P_r)} \\det{B} = \\det{A} \\det{B}\r\n\\end{flalign}\r\n$$\r\n\r\n当 det A = 0 时\r\n\r\n$$\r\n\\begin{flalign}\r\n&amp; 此时任意的 A 都可以通过一个矩阵 O 通过任意次初等变换得到 \\\\\r\n&amp; 这里的 O = \\left(\r\n        \\begin{matrix}\r\n            1 \\\\\r\n            &amp; 1 \\\\\r\n            &amp; &amp; \\ddots \\\\\r\n            &amp; &amp; &amp; 0\r\n        \\end{matrix}\r\n    \\right) \\\\\r\n&amp; 则记 A = P_1 P_2 \\cdots P_s O，(P_1, P_2, \\cdots P_s 为初等矩阵)\r\n\\\\\r\n&amp; \\det{AB} = \\det{(P_1 P_2 \\cdots P_s O B)} = \\det{P_1} \\det{P_2}\r\n\\cdots \\det{P_s} \\det{O} \\det{B} \\\\\r\n&amp; = 0 = \\det{A}\\det{B}\r\n\\end{flalign}\r\n$$\r\n证毕。\r\n","categories":["线性代数"],"tags":["数学","线性代数","矩阵"]},{"title":"证明O'Stolz定理","url":"/2025/10/01/%E8%AF%81%E6%98%8EO-Stolz%E5%AE%9A%E7%90%86/","content":"O’Stolz 定理的简单证明\r\nO’Stolz 定理的简单描述\r\n该定理可以认为是 L’Hospital 法则在数列函数上的特殊情况。\r\n$Th1: (\\frac{*}{\\infty})$型: 设数列\r\n{an}, {bn}\r\n满足以下条件:\r\n\r\n{bn}\r\n严格单调递增,且 bn &gt; 0,\r\n$\\lim\\limits_{n\\to \\infty}b_n =\r\n+\\infty$.\r\n\r\n则 $\\lim\\limits_{n\\to\r\n\\infty}\\frac{a_n}{b_n}=\\lim\\limits_{n\\to \\infty}\\frac{a_{n+1} -\r\na_n}{b_{n+1} - b_n}=L$, 其中L为有限数或无穷大量.\r\n$Th2:(\\frac{0}{0}$)型: 设数列 {an}, {bn}\r\n满足以下条件:\r\n\r\n{bn}\r\n严格单调递减且 $\\lim\\limits_{n\\to\r\n\\infty}b_n=0$,\r\n$\\lim\\limits_{n\\to\r\n\\infty}a_n=0$.\r\n\r\n则 $\\lim\\limits_{n\\to\r\n\\infty}\\frac{a_n}{b_n}=\\lim\\limits_{n\\to \\infty}\\frac{a_{n+1} -\r\na_n}{b_{n+1}- b_n}=L$, 其中L为有限数或无穷大量.\r\n\r\n\r\n定理证明\r\n类型一\r\nProve:\r\n由 $\\lim\\limits_{n\\to \\infty}\\frac{a_{n+1}\r\n- a_n}{b_{n+1} - b_n}=L$, 得∀ϵ &gt; 0 ∃N1,\r\n当n &gt; N1时有:\r\n$$\r\n\\begin{flalign}\r\n\\left|\\frac{a_{n+1}-a_n}{b_{n+1}-b_n}-L\\right|&amp;&lt;\\epsilon\\\\\r\n即有，L-\\epsilon&lt;\\frac{a_{n+1}-a_n}{b_{n+1}-b_n}&amp;&lt;L+\\epsilon\r\n\\end{flalign}\r\n$$\r\n∵{bn}严格单调递增，且bn + 1 &gt; bn &gt; 0.\r\n∴ (L − ϵ)(bn + 1 − bn) &lt; an + 1 − an &lt; (L + ϵ)(bn + 1 − bn)\r\n由 $\\lim\\limits_{n\\to\r\n\\infty}b_n=+\\infty$,得∃N2,使得n &gt; N2时,\r\nbn &gt; ϵ &gt; 0.\r\n可得到 $\\lim\\limits_{n\\to\r\n\\infty}\\frac{1}{b_n}=0$.\r\n取 N = max {N1, N2},\r\n则N已确定，当n &gt; N时，有:\r\n$$\r\n\\begin{flalign}\r\n(L-\\epsilon)(b_{N+2}-b_{N+1})&lt;a_{N+2}-a_{N+1}&amp;&lt;(L+\\epsilon)(b_{N+2}-b_{N+1})\\\\\r\n(L-\\epsilon)(b_{N+3}-b_{N+2})&lt;a_{N+3}-a_{N+2}&amp;&lt;(L+\\epsilon)(b_{N+3}-b_{N+2})\\\\\r\n&amp;...\\\\\\\\\r\n(L-\\epsilon)(b_{n+1}-b_n)&lt;a_{n+1}-a_n&amp;&lt;(L+\\epsilon)(b_{n+1}-b_n)\r\n\\end{flalign}\r\n$$\r\n将上式累加得到:\r\n$$\r\n\\begin{flalign}\r\n(L-\\epsilon)(b_{n+1}-b_{N+1})&lt;a_{n+1}-a_{N+1}&amp;&lt;(L+\\epsilon)(b_{n+1}-b_{N+1})\\\\\\\\\r\n即有L-\\epsilon&lt;\\frac{a_{n+1}-a_{N+1}}{b_{n+1}-b_{N+1}}&amp;&lt;L+\\epsilon\\\\\\\\\r\n化为L-\\epsilon&lt;\\frac{\\frac{a_{n+1}}{b_{n+1}}-\\frac{a_{N+1}}{b_{n+1}}}{1-\\frac{b_{N+1}}{b_{n+1}}}&amp;&lt;L+\\epsilon\\\\\\\\\r\n则\\left|\\frac{\\frac{a_{n+1}}{b_{n+1}}-\\frac{a_{N+1}}{b_{n+1}}}{1-\\frac{b_{N+1}}{b_{n+1}}}-L\\right|&amp;&lt;\\epsilon\r\n\\end{flalign}\r\n$$\r\n故 $\\lim\\limits_{n\\to\r\n\\infty}\\frac{\\frac{a_{n+1}}{b_{n+1}}-\\frac{a_{N+1}}{b_{n+1}}}{1-\\frac{b_{N+1}}{b_{n+1}}}=L$.\r\n而对上述极限利用极限性质进行拆分可得到:\r\n$$\r\n\\begin{flalign}\r\n&amp;\\lim\\limits_{n\\to\r\n\\infty}\\frac{\\frac{a_{n+1}}{b_{n+1}}-\\frac{a_{N+1}}{b_{n+1}}}{1-\\frac{b_{N+1}}{b_{n+1}}}\\\\\r\n=&amp;\\frac{\\lim\\limits_{n\\to\r\n\\infty}\\frac{a_{n+1}}{b_{n+1}}-a_{N+1}\\lim\\limits_{n\\to\r\n\\infty}\\frac{1}{b_{n+1}}}{1-b_{N+1}\\lim\\limits_{n\\to\r\n\\infty}\\frac{1}{b_{n+1}}}\\\\\r\n=&amp;\\frac{\\lim\\limits_{n\\to \\infty}\\frac{a_{n+1}}{b_{n+1}}-0}{1-0}\\\\\r\n=&amp;\\lim\\limits_{n\\to \\infty}\\frac{a_{n+1}}{b_{n+1}}\\\\\r\n=&amp;L\r\n\\end{flalign}\r\n$$\r\n即 $\\lim\\limits_{n\\to\r\n\\infty}\\frac{a_n}{b_n}=L$.\r\n证毕。\r\n类型二\r\nProve:\r\n得条件 $\\lim\\limits_{n\\to\r\n\\infty}a_n=0,\\lim\\limits_{n\\to \\infty}b_n=0$ 且{bn}严格单调递减\r\n.\r\n令 cn = an − Lbn,\r\n则 $\\lim\\limits_{n\\to\r\n\\infty}c_n=0$.\r\n当 ∀ϵ &gt; 0, ∃N使得 n ≥ N 时有: $$\r\n\\begin{flalign}\r\n\\left|\\frac{a_{n+1}-a_n}{b_{n+1}-b_n}-L\\right|&amp;&lt;\\epsilon\\\\\r\n即，\\left|a_{n+1}-a_n-L(b_{n+1}-b_n)\\right|&amp;&lt;\\epsilon\\left|b_{n+1}-b_n\\right|\\\\\r\n则，\\left|c_{n+1}-c_n\\right|&amp;&lt;\\epsilon\\left|b_{n+1}-b_n\\right|\r\n\\end{flalign}\r\n$$ ∵{bn}\r\n严格单调递减，∴ |cn + 1 − cn| &lt; ϵ(bn + 1 − bn).\r\n∀n &gt; m ≥ N（即m此时唯一确定）\r\n由三角不等式得到: $$\r\n\\begin{flalign}\r\n&amp;\\left|c_n-c_m\\right|\\\\\r\n=&amp;\\left|\\sum_{k=m}^{n-1}(c_{k+1}-c_k)\\right|\\\\\r\n\\leq&amp;\\sum_{k=m}^{n-1}\\left|c_{k+1}-c_k\\right|\\\\\r\n&lt;&amp;\\epsilon\\sum_{k=m}^{n-1}(b_k-b_{k+1})\\\\\r\n=&amp;\\epsilon(b_m-b_n)\r\n\\end{flalign}\r\n$$ 不妨令 n → ∞, 由\r\ncn → 0, bn → 0, bn &gt; 0\r\n得:\r\n|−cm| ≤ ϵbm,\r\n即 |cm| ≤ ϵbm,\r\n故 $\\forall m\\geq\r\nN,\\left|\\frac{c_m}{b_m}\\right|&lt;\\epsilon$.\r\n即 $\\lim\\limits_{n\\to\r\n\\infty}\\frac{c_m}{b_m}=0，\\lim\\limits_{n\\to\r\n\\infty}\\frac{a_m-Lb_m}{b_m}=0，\\lim\\limits_{n\\to\r\n\\infty}\\frac{a_m}{b_m}=0$.\r\n综上 $\\lim\\limits_{n\\to\r\n\\infty}\\frac{a_n}{b_n}=L$.\r\n证毕。\r\n\r\n例题\r\n\r\ne.g. 求极限 $\\lim\\limits_{n\\to\r\n\\infty}\\frac{1+\\sqrt{2}+\\cdots+\\sqrt[n]{n}}{n}$\r\n\r\n​ 解: $$\r\n\\begin{flalign}\r\n&amp;\\lim\\limits_{n\\to\r\n\\infty}\\frac{\\sum_{i}^{n+1}\\sqrt[i]{i}-\\sum_{j}^{n}\\sqrt[j]{j}}{\\sum_{i}^{n+1}i-\\sum_{j}^{n}j}\\\\\r\n=&amp;\\lim\\limits_{n\\to \\infty}\\frac{\\sqrt[n+1]{n+1}}{1}\\\\\r\n=&amp;\\lim\\limits_{n\\to \\infty}\\sqrt[n+1]{n+1}\\\\\r\n=&amp;1\\\\\r\n\\\\\r\n&amp;\\lim\\limits_{n\\to \\infty}\\frac{1+\\sqrt{2}+\\cdots+\\sqrt[n]{n}}{n} =\r\n1\r\n\\end{flalign}\r\n$$ ​ 注: 一个重要极限 $\\lim\\limits_{n\\to\r\n\\infty}\\sqrt[n]{n}=1$\r\n\r\n\r\ne.g. 设 xn &gt; 0, 且\r\n$\\lim\\limits_{n\\to\r\n\\infty}\\frac{x_{n+1}}{x_n}=r$, 证明 $\\lim\\limits_{n\\to\r\n\\infty}\\sqrt[n]{x_n}=r$\r\n\r\n​ Prove:\r\n​ 利用同构思想，构建 $\\sqrt[n]{x_n}=x_n^\\frac{1}{n}=e^{\\frac{\\ln\r\nx_n}{n}}$。\r\n​ 则有 $$\r\n\\begin{flalign}\r\n&amp;\\lim\\limits_{n\\to \\infty}\\ln \\frac{x_{n+1}}{x_n}\\\\\r\n=&amp;\\lim\\limits_{n\\to \\infty}(\\ln x_{n+1}-\\ln x_n)\\\\\r\n=&amp;\\lim\\limits_{n\\to \\infty}\\ln x_{n+1}-\\lim\\limits_{n\\to \\infty}\\ln\r\nx_n\\\\\r\n=&amp;\\ln\\lim\\limits_{n\\to \\infty}\\frac{x_{n+1}}{x_n}\\\\\r\n=&amp;\\ln r\r\n\\end{flalign}\r\n$$ ​ 故有 $$\r\n\\begin{flalign}\r\n&amp;\\lim\\limits_{n\\to \\infty}\\frac{\\ln x_n}{n}\\\\\r\n=&amp;\\lim\\limits_{n\\to \\infty}\\frac{\\ln x_{n+1}-\\ln x}{n+1-n}\\\\\r\n=&amp;\\lim\\limits_{n\\to \\infty}\\ln (x_{n+1}-\\ln x)\\\\\r\n=&amp;\\ln r\r\n\\end{flalign}\r\n$$ ​ 则 $\\lim\\limits_{n\\to\r\n\\infty}\\sqrt[n]{x_n}=\\lim\\limits_{n\\to \\infty}e^{\\frac{\\ln\r\nx_n}{n}}=e^{\\lim\\limits_{n\\to \\infty}\\frac{\\ln x_n}{n}}=e^{\\ln\r\nr}=r$\r\n​ 证毕。\r\n​ 注: 两个重要结论 $\\lim\\limits_{n\\to\r\n\\infty}e^{a_n}=e^{\\lim\\limits_{n\\to \\infty} a_n}$, $\\lim\\limits_{n\\to \\infty}\\ln a_n=\\ln\r\n\\lim\\limits_{n\\to \\infty}a_n$\r\n注注: 也许某一天会给出上述两个重要结论的证明，先鸽了（咕咕）。\r\n","categories":["微积分I"],"tags":["数学","微积分","极限"]}]